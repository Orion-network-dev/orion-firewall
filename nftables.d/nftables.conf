#!/usr/sbin/nft -f

table ip orion
delete table ip orion

define orion = {
    10.30.0.0/15,
    172.30.0.0/15
}
define myself = __TODO__

table inet orion {

    # Chaîne PREROUTING pour gérer le DNAT avant le routage des paquets
    chain prerouting {
        type nat hook prerouting priority 1000
        jump orionExposedNat  # Redirige vers la chaîne orionExposedNat pour appliquer les règles de DNAT
    }

    # Chaîne OUTPUT pour appliquer le DNAT aux paquets générés localement
    chain output {
        type nat hook output priority 1000
        jump orionExposedNat  # Redirige vers la chaîne orionExposedNat
    }

    # Chaîne INPUT pour le filtrage des paquets entrants
    chain input {
        type filter hook input priority filter
        # Règles de filtrage définies ici (actuellement aucune)
        iifgroup 30 jump input_orion_interfaces
    }

    # Chaîne POSTROUTING pour gérer le SNAT après le routage des paquets
    chain postrouting {
        type nat hook postrouting priority 0

        # SNAT pour tous les paquets dont l'adresse source n'appartient pas à ORION et dont la destination est dans ORION
        ip saddr != $orion ip daddr $orion iifgroup != 30 \
            snat ip to numgen inc mod 2 map $myself

        # SNAT pour les paquets dont l'adresse source n'est pas ORION et qui ont déjà été DNAT
        ip saddr != $orion iifgroup != 30 ct status dnat \
            snat ip to numgen inc mod 2 map $myself

        jump orionSourceNat  # Redirige vers la chaîne orionSourceNat pour appliquer les règles de SNAT
    }

    # Chaîne FORWARD pour filtrer les paquets transférés entre interfaces
    chain forward {
        type filter hook forward priority filter
        policy accept  # Politique par défaut : rejeter tout le trafic transféré

        # Applique la chaîne "forward_orion_interfaces" au trafic provenant des interfaces du groupe Orion (iifgroup 30)
        iifgroup 30 jump forward_orion_interfaces
    }

    # Règle appliquée aux interfaces orion
	chain forward_orion_interfaces {
		# On accepte les traffic déja établi
		ct state established,related accept
		# On accepte le traffic qui a été dst-nat (exposé ou autre)
		ct status dnat accept
		# On accepte le traffic ayant comme destination une autre interface
		oifgroup 30 accept
		# On rejette tout autre traffic
		reject with icmp admin-prohibited
	}

    # Règle appliquée aux interface orion
    chain input_orion_interfaces {
        ip protocol icmp accept
        tcp dport 179 counter accept
		reject with icmp admin-prohibited
    }


    # Map pour les redirections DNAT pour TCP et UDP, basée sur les adresses IP et ports
    map ports {
        type ipv4_addr . inet_service : ipv4_addr . inet_service
    }

    # Map pour les redirections DNAT pour ICMP (uniquement les adresses IP, pas de ports)
    map icmp_map {
        type ipv4_addr : ipv4_addr
    }

    # Map pour les redirections SNAT pour TCP et UDP (modifie les adresses IP et ports source)
    map snat_ports {
        type ipv4_addr . inet_service : ipv4_addr . inet_service
    }

    # Map pour les redirections SNAT pour ICMP (modifie uniquement les adresses IP source)
    map snat_icmp_map {
        type ipv4_addr : ipv4_addr
    }

    # Chaîne orionExposedNat pour gérer le DNAT (translation d'adresse de destination)
    chain orionExposedNat {
        # DNAT pour TCP et UDP en utilisant la map
        ip protocol { tcp, udp } dnat to ip daddr . th dport map @ports

        # DNAT pour ICMP en utilisant la map
        ip protocol icmp dnat to ip daddr map @icmp_map
    }

    # Chaîne orionSourceNat pour gérer le SNAT (translation d'adresse de source)
    chain orionSourceNat {
        # SNAT pour TCP et UDP en utilisant la map
        ip protocol { tcp, udp } snat to ip saddr . th sport map @snat_ports

        # SNAT pour ICMP en utilisant la map
        ip protocol icmp snat to ip saddr map @snat_icmp_map
    }
}
